<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>
        
            如何实现一个基于 DOM 的模板引擎 - Meitu FE
        
    </title>
    <meta name="keywords" content="">
    <meta name="description" content="">
    <link rel="shortcut icon" href="/favicon.ico">
    <link rel="stylesheet" href="/dist/css/github-gist.css">
    <link rel="stylesheet" href="/dist/css/app.css">
</head>


<body data-page="article">


<header class="header">
    <nav class="nav">
        <div class="container">
            <div class="logo">
                <a href="http://fe.meitu.com">
                    <img src="/images/logo.png" alt="Meitu FE">
                </a>
            </div>
            <ul class="menu">
                
                <li><a href="/">HOME</a></li>
                
                <li><a href="https://github.com/meitufe">GITHUB</a></li>
                
            </ul>
        </div>
    </nav>
</header>


<div class="page-content">
    <div class="container">
        <article class="article">
            <header class="article-header">
                <h1 class="article-title">如何实现一个基于 DOM 的模板引擎</h1>
                <div class="article-meta">
                    <span>🌰</span>
                    <span>publish at</span>
                    <time class="article-date" datetime="2017-08-06">2017-08-06</time>
                </div>
            </header>
            <section class="article-content">
                 <p>可能你已经体会到了 <code>Vue</code> 所带来的便捷了，相信有一部分原因也是因为其基于 DOM 的语法简洁的模板渲染引擎。这篇文章将会介绍如何实现一个基于 DOM 的模板引擎（就像 <code>Vue</code> 的模板引擎一样）。</p>
<h2 id="Preface"><a href="#Preface" class="headerlink" title="Preface"></a>Preface</h2><p>开始之前，我们先来看一下最终的效果：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> compiled = Compile(<span class="string">`&lt;h1&gt;Hey 🌰, &#123;&#123; greeting &#125;&#125;&lt;/h1&gt;`</span>, &#123;</div><div class="line">    greeting: <span class="string">`Hello World`</span>,</div><div class="line">&#125;);</div><div class="line">compiled.view <span class="comment">// =&gt; `&lt;h1&gt;Hey 🌰, Hello World&lt;/h1&gt;`</span></div></pre></td></tr></table></figure>
<h2 id="Compile"><a href="#Compile" class="headerlink" title="Compile"></a>Compile</h2><p>实现一个模板引擎实际上就是实现一个编译器，就像这样：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> compiled = Compile(template: <span class="built_in">String</span>|Node, <span class="attr">data</span>: <span class="built_in">Object</span>);</div><div class="line">compiled.view <span class="comment">// =&gt; compiled template</span></div></pre></td></tr></table></figure>
<p>首先，让我们来看下 <code>Compile</code> 内部是如何实现的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// compile.js</span></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * template compiler</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * @param &#123;String|Node&#125; template</span></div><div class="line"><span class="comment"> * @param &#123;Object&#125; data</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Compile</span>(<span class="params">template, data</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (!(<span class="keyword">this</span> <span class="keyword">instanceof</span> Compile)) <span class="keyword">return</span> <span class="keyword">new</span> Compile(template, data);</div><div class="line"></div><div class="line">    <span class="keyword">this</span>.options = &#123;&#125;;</div><div class="line">    <span class="keyword">this</span>.data = data;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (template <span class="keyword">instanceof</span> Node) &#123;</div><div class="line">        <span class="keyword">this</span>.options.template = template;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> template === <span class="string">'string'</span>) &#123;</div><div class="line">        <span class="keyword">this</span>.options.template = domify(template);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="built_in">console</span>.error(<span class="string">`"template" only accept DOM node or string template`</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    template = <span class="keyword">this</span>.options.template;</div><div class="line"></div><div class="line">    walk(template, (node, next) =&gt; &#123;</div><div class="line">        <span class="keyword">if</span> (node.nodeType === <span class="number">1</span>) &#123;</div><div class="line">            <span class="comment">// compile element node</span></div><div class="line">            <span class="keyword">this</span>.compile.elementNodes.call(<span class="keyword">this</span>, node);</div><div class="line">            <span class="keyword">return</span> next();</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node.nodeType === <span class="number">3</span>) &#123;</div><div class="line">            <span class="comment">// compile text node</span></div><div class="line">            <span class="keyword">this</span>.compile.textNodes.call(<span class="keyword">this</span>, node);</div><div class="line">        &#125;</div><div class="line">        next();</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    <span class="keyword">this</span>.view = template;</div><div class="line">    template = <span class="literal">null</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Compile.compile = &#123;&#125;;</div></pre></td></tr></table></figure>
<h3 id="walk"><a href="#walk" class="headerlink" title="walk"></a>walk</h3><p>通过上面的代码，可以看到 <code>Compile</code> 的构造函数主要就是做了一件事 ———— 遍历 <code>template</code>，然后通过判断节点类型的不同来做不同的编译操作，这里就不介绍如何遍历 <code>template</code> 了，不明白的话可以直接看 <code>walk</code> <a href="https://github.com/colonjs/colon/blob/master/src/compile/walk.js" target="_blank" rel="external">函数的源码</a>，我们着重来看下如何编译这些不同类型的节点，以编译 <code>node.nodeType === 1</code> 的元素节点为例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * compile element node</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * @param &#123;Node&#125; node</span></div><div class="line"><span class="comment"> */</span></div><div class="line">Compile.compile.elementNodes = <span class="function"><span class="keyword">function</span> (<span class="params">node</span>) </span>&#123;</div><div class="line">    <span class="keyword">const</span> bindSymbol = <span class="string">`:`</span>;</div><div class="line">    <span class="keyword">let</span> attributes = [].slice.call(node.attributes),</div><div class="line">        attrName = <span class="string">``</span>,</div><div class="line">        attrValue = <span class="string">``</span>,</div><div class="line">        directiveName = <span class="string">``</span>;</div><div class="line"></div><div class="line">    attributes.map(<span class="function"><span class="params">attribute</span> =&gt;</span> &#123;</div><div class="line">        attrName = attribute.name;</div><div class="line">        attrValue = attribute.value.trim();</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (attrName.indexOf(bindSymbol) === <span class="number">0</span> &amp;&amp; attrValue !== <span class="string">''</span>) &#123;</div><div class="line">            directiveName = attrName.slice(bindSymbol.length);</div><div class="line"></div><div class="line">            <span class="keyword">this</span>.bindDirective(&#123;</div><div class="line">                node,</div><div class="line">                expression: attrValue,</div><div class="line">                name: directiveName,</div><div class="line">            &#125;);</div><div class="line">            node.removeAttribute(attrName);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">this</span>.bindAttribute(node, attribute);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>噢忘记说了，这里我参考了 <code>Vue</code> 的指令语法，就是在带有冒号 <code>:</code> 的属性名中（当然这里也可以是任何其他你所喜欢的符号），可以直接写 JavaScript 的表达式，然后也会提供几个特殊的指令，例如 <code>:text</code>, <code>:show</code> 等等来对元素做一些不同的操作。</p>
<p>其实该函数只做了两件事：</p>
<ul>
<li>遍历该节点的所有属性，通过判断属性类型的不同来做不同的操作，判断的标准就是属性名是否是冒号 <code>:</code> 开头并且属性的值不为空；</li>
<li>绑定相应的指令去更新属性。</li>
</ul>
<h2 id="Directive"><a href="#Directive" class="headerlink" title="Directive"></a>Directive</h2><p>其次，再看一下 <code>Directive</code> 内部是如何实现的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> directives <span class="keyword">from</span> <span class="string">'./directives'</span>;</div><div class="line"><span class="keyword">import</span> &#123; generate &#125; <span class="keyword">from</span> <span class="string">'./compile/generate'</span>;</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">Directive</span>(<span class="params">options = &#123;&#125;</span>) </span>&#123;</div><div class="line">    <span class="built_in">Object</span>.assign(<span class="keyword">this</span>, options);</div><div class="line">    <span class="built_in">Object</span>.assign(<span class="keyword">this</span>, directives[<span class="keyword">this</span>.name]);</div><div class="line">    <span class="keyword">this</span>.beforeUpdate &amp;&amp; <span class="keyword">this</span>.beforeUpdate();</div><div class="line">    <span class="keyword">this</span>.update &amp;&amp; <span class="keyword">this</span>.update(generate(<span class="keyword">this</span>.expression)(<span class="keyword">this</span>.compile.options.data));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>Directive</code> 做了三件事：</p>
<ul>
<li>注册指令（<code>Object.assign(this, directives[this.name])</code>）；</li>
<li>计算指令表达式的实际值（<code>generate(this.expression)(this.compile.options.data)</code>）；</li>
<li>把计算出来的实际值更新到 DOM 上面(<code>this.update()</code>)。</li>
</ul>
<p>在介绍指令之前，先看一下它的用法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">Compile.prototype.bindDirective = <span class="function"><span class="keyword">function</span> (<span class="params">options</span>) </span>&#123;</div><div class="line">    <span class="keyword">new</span> Directive(&#123;</div><div class="line">        ...options,</div><div class="line">        compile: <span class="keyword">this</span>,</div><div class="line">    &#125;);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">Compile.prototype.bindAttribute = <span class="function"><span class="keyword">function</span> (<span class="params">node, attribute</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (!hasInterpolation(attribute.value) || attribute.value.trim() == <span class="string">''</span>) <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line"></div><div class="line">    <span class="keyword">this</span>.bindDirective(&#123;</div><div class="line">        node,</div><div class="line">        name: <span class="string">'attribute'</span>,</div><div class="line">        expression: parse.text(attribute.value),</div><div class="line">        attrName: attribute.name,</div><div class="line">    &#125;);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p><code>bindDirective</code> 对 <code>Directive</code> 做了一个非常简单的封装，接受三个必填属性：</p>
<ul>
<li><code>node</code>: 当前所编译的节点，在 <code>Directive</code> 的 <code>update</code> 方法中用来更新当前节点；</li>
<li><code>name</code>: 当前所绑定的指令名称，用来区分具体使用哪个指令更新器来更新视图；</li>
<li><code>expression</code>: parse 之后的 JavaScript 的表达式。</li>
</ul>
<h3 id="updater"><a href="#updater" class="headerlink" title="updater"></a>updater</h3><p>在 <code>Directive</code> 内部我们通过 <code>Object.assign(this, directives[this.name]);</code> 来注册不同的指令，所以变量 <code>directives</code> 的值可能是这样的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// directives</span></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</div><div class="line">    <span class="comment">// directive `:show`</span></div><div class="line">    show: &#123;</div><div class="line">        beforeUpdate() &#123;&#125;,</div><div class="line">        update(show) &#123;</div><div class="line">            <span class="keyword">this</span>.node.style.display = show ? <span class="string">`block`</span> : <span class="string">`none`</span>;</div><div class="line">        &#125;,</div><div class="line">    &#125;,</div><div class="line">    <span class="comment">// directive `:text`</span></div><div class="line">    text: &#123;</div><div class="line">        beforeUpdate() &#123;&#125;,</div><div class="line">        update(value) &#123;</div><div class="line">            <span class="comment">// ...</span></div><div class="line">        &#125;,</div><div class="line">    &#125;,</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>所以假设某个指令的名字是 <code>show</code> 的话，那么 <code>Object.assign(this, directives[this.name]);</code> 就等同于：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Object</span>.assign(<span class="keyword">this</span>, &#123;</div><div class="line">    beforeUpdate() &#123;&#125;,</div><div class="line">    update(show) &#123;</div><div class="line">        <span class="keyword">this</span>.node.style.display = show ? <span class="string">`block`</span> : <span class="string">`none`</span>;</div><div class="line">    &#125;,</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>表示对于指令 <code>show</code>，指令更新器会改变该元素 <code>style</code> 的 <code>display</code> 值，从而实现对应的功能。所以你会发现，整个编译器结构设计好后，如果我们要拓展功能的话，只需简单地编写指令的更新器即可，这里再以指令 <code>text</code> 举个例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// directives</span></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</div><div class="line">    <span class="comment">// directive `:show`</span></div><div class="line">    <span class="comment">// show: &#123; ... &#125;,</span></div><div class="line">    <span class="comment">// directive `:text`</span></div><div class="line">    text: &#123;</div><div class="line">        update(value) &#123;</div><div class="line">            <span class="keyword">this</span>.node.textContent = value;</div><div class="line">        &#125;,</div><div class="line">    &#125;,</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>有没有发现编写一个指令其实非常的简单，然后我们就可以这么使用我们的 <code>text</code> 指令了：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> compiled = Compile(<span class="string">`&lt;h1 :text="'Hey 🌰, ' + greeting"&gt;&lt;/h1&gt;`</span>, &#123;</div><div class="line">    greeting: <span class="string">`Hello World`</span>,</div><div class="line">&#125;);</div><div class="line">compiled.view <span class="comment">// =&gt; `&lt;h1&gt;Hey 🌰, Hello World&lt;/h1&gt;`</span></div></pre></td></tr></table></figure>
<h3 id="generate"><a href="#generate" class="headerlink" title="generate"></a>generate</h3><p>讲到这里，其实还有一个非常重要的点没有提到，就是我们如何把 <code>data</code> 真实数据渲染到模板中，比如 <code>&lt;h1&gt;Hey 🌰, &lt;/h1&gt;</code> 如何渲染成 <code>&lt;h1&gt;Hey 🌰, Hello World&lt;/h1&gt;</code>，通过下面三个步骤即可计算出表达式的真实数据：</p>
<ul>
<li>把 <code>&lt;h1&gt;Hey 🌰, &lt;/h1&gt;</code> 解析成 <code>&#39;Hey 🌰, &#39; + greeting</code> 这样的 JavaScript 表达式；</li>
<li>提取其中的依赖变量并取得所在 <code>data</code> 中的对应值；</li>
<li>利用 <code>new Function()</code> 来创建一个匿名函数来返回这个表达式；</li>
<li>最后通过调用这个匿名函数来返回最终计算出来的数据并通过指令的 <code>update</code> 方法更新到视图中。</li>
</ul>
<h4 id="parse-text"><a href="#parse-text" class="headerlink" title="parse text"></a>parse text</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// reference: https://github.com/vuejs/vue/blob/dev/src/compiler/parser/text-parser.js#L15-L41</span></div><div class="line"><span class="keyword">const</span> tagRE = <span class="regexp">/\&#123;\&#123;((?:.|\n)+?)\&#125;\&#125;/g</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">parse</span>(<span class="params">text</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (!tagRE.test(text)) <span class="keyword">return</span> <span class="built_in">JSON</span>.stringify(text);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> tokens = [];</div><div class="line">    <span class="keyword">let</span> lastIndex = tagRE.lastIndex = <span class="number">0</span>;</div><div class="line">    <span class="keyword">let</span> index, matched;</div><div class="line"></div><div class="line">    <span class="keyword">while</span> (matched = tagRE.exec(text)) &#123;</div><div class="line">        index = matched.index;</div><div class="line">        <span class="keyword">if</span> (index &gt; lastIndex) &#123;</div><div class="line">            tokens.push(<span class="built_in">JSON</span>.stringify(text.slice(lastIndex, index)));</div><div class="line">        &#125;</div><div class="line">        tokens.push(matched[<span class="number">1</span>].trim());</div><div class="line">        lastIndex = index + matched[<span class="number">0</span>].length;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (lastIndex &lt; text.length) tokens.push(<span class="built_in">JSON</span>.stringify(text.slice(lastIndex)));</div><div class="line"></div><div class="line">    <span class="keyword">return</span> tokens.join(<span class="string">'+'</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>该函数我是直接参考 <code>Vue</code> 的实现，它会把含有双花括号的字符串解析成标准的 JavaScript 表达式，例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">parse(<span class="string">`Hi &#123;&#123; user.name &#125;&#125;, &#123;&#123; colon &#125;&#125; is awesome.`</span>);</div><div class="line"><span class="comment">// =&gt; 'Hi ' + user.name + ', ' + colon + ' is awesome.'</span></div></pre></td></tr></table></figure>
<h4 id="extract-dependency"><a href="#extract-dependency" class="headerlink" title="extract dependency"></a>extract dependency</h4><p>我们会通过下面这个函数来提取出一个表达式中可能存在的变量：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> dependencyRE = <span class="regexp">/"[^"]*"|'[^']*'|\.\w*[a-zA-Z$_]\w*|\w*[a-zA-Z$_]\w*:|(\w*[a-zA-Z$_]\w*)/g</span>;</div><div class="line"><span class="keyword">const</span> globals = [</div><div class="line">    <span class="string">'true'</span>, <span class="string">'false'</span>, <span class="string">'undefined'</span>, <span class="string">'null'</span>, <span class="string">'NaN'</span>, <span class="string">'isNaN'</span>, <span class="string">'typeof'</span>, <span class="string">'in'</span>,</div><div class="line">    <span class="string">'decodeURI'</span>, <span class="string">'decodeURIComponent'</span>, <span class="string">'encodeURI'</span>, <span class="string">'encodeURIComponent'</span>, <span class="string">'unescape'</span>,</div><div class="line">    <span class="string">'escape'</span>, <span class="string">'eval'</span>, <span class="string">'isFinite'</span>, <span class="string">'Number'</span>, <span class="string">'String'</span>, <span class="string">'parseFloat'</span>, <span class="string">'parseInt'</span>,</div><div class="line">];</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">extractDependencies</span>(<span class="params">expression</span>) </span>&#123;</div><div class="line">    <span class="keyword">const</span> dependencies = [];</div><div class="line"></div><div class="line">    expression.replace(dependencyRE, (match, dependency) =&gt; &#123;</div><div class="line">        <span class="keyword">if</span> (</div><div class="line">            dependency !== <span class="literal">undefined</span> &amp;&amp;</div><div class="line">            dependencies.indexOf(dependency) === <span class="number">-1</span> &amp;&amp;</div><div class="line">            globals.indexOf(dependency) === <span class="number">-1</span></div><div class="line">        ) &#123;</div><div class="line">            dependencies.push(dependency);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> dependencies;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过正则表达式 <code>dependencyRE</code> 匹配出可能的变量依赖后，还要进行一些对比，比如是否是全局变量等等。效果如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">extractDependencies(<span class="string">`typeof String(name) === 'string'  &amp;&amp; 'Hello ' + world + '! ' + hello.split('').join('') + '.'`</span>);</div><div class="line"><span class="comment">// =&gt; ["name", "world", "hello"]</span></div></pre></td></tr></table></figure>
<p>这正是我们需要的结果，<code>typeof</code>, <code>String</code>, <code>split</code> 和 <code>join</code> 并不是 <code>data</code> 中所依赖的变量，所以不需要被提取出来。</p>
<h4 id="generate-1"><a href="#generate-1" class="headerlink" title="generate"></a>generate</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">generate</span>(<span class="params">expression</span>) </span>&#123;</div><div class="line">    <span class="keyword">const</span> dependencies = extractDependencies(expression);</div><div class="line">    <span class="keyword">let</span> dependenciesCode = <span class="string">''</span>;</div><div class="line"></div><div class="line">    dependencies.map(<span class="function"><span class="params">dependency</span> =&gt;</span> dependenciesCode += <span class="string">`var <span class="subst">$&#123;dependency&#125;</span> = this.get("<span class="subst">$&#123;dependency&#125;</span>"); `</span>);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">`data`</span>, <span class="string">`<span class="subst">$&#123;dependenciesCode&#125;</span>return <span class="subst">$&#123;expression&#125;</span>;`</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们提取变量的目的就是为了在 <code>generate</code> 函数中生成相应的变量赋值的字符串便于在 <code>generate</code> 函数中使用，例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">`data`</span>, <span class="string">`</span></div><div class="line"><span class="string">    var name = data["name"];</span></div><div class="line"><span class="string">    var world = data["world"];</span></div><div class="line"><span class="string">    var hello = data["hello"];</span></div><div class="line"><span class="string">    return typeof String(name) === 'string'  &amp;&amp; 'Hello ' + world + '! ' + hello.split('').join('') + '.';</span></div><div class="line"><span class="string">`</span>);</div><div class="line"></div><div class="line"><span class="comment">// will generated:</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">anonymous</span>(<span class="params">data</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> name = data[<span class="string">"name"</span>];</div><div class="line">    <span class="keyword">var</span> world = data[<span class="string">"world"</span>];</div><div class="line">    <span class="keyword">var</span> hello = data[<span class="string">"hello"</span>];</div><div class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> <span class="built_in">String</span>(name) === <span class="string">'string'</span>  &amp;&amp; <span class="string">'Hello '</span> + world + <span class="string">'! '</span> + hello.split(<span class="string">''</span>).join(<span class="string">''</span>) + <span class="string">'.'</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样的话，只需要在调用这个匿名函数的时候传入对应的 <code>data</code> 即可获得我们想要的结果了。现在回过头来看之前的 <code>Directive</code> 部分代码应该就一目了然了：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Directive</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span>(options = &#123;&#125;) &#123;</div><div class="line">        <span class="comment">// ...</span></div><div class="line">        <span class="keyword">this</span>.beforeUpdate &amp;&amp; <span class="keyword">this</span>.beforeUpdate();</div><div class="line">        <span class="keyword">this</span>.update &amp;&amp; <span class="keyword">this</span>.update(generate(<span class="keyword">this</span>.expression)(<span class="keyword">this</span>.compile.data));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>generate(this.expression)(this.compile.data)</code> 就是表达式经过 <code>this.compile.data</code> 计算后我们所需要的值。</p>
<h3 id="compile-text-node"><a href="#compile-text-node" class="headerlink" title="compile text node"></a>compile text node</h3><p>我们前面只讲了如何编译 <code>node.nodeType === 1</code> 的元素节点，那么文字节点如何编译呢，其实理解了前面所讲的内容话，文字节点的编译就简单得不能再简单了：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * compile text node</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * @param &#123;Node&#125; node</span></div><div class="line"><span class="comment"> */</span></div><div class="line">Compile.compile.textNodes = <span class="function"><span class="keyword">function</span> (<span class="params">node</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (node.textContent.trim() === <span class="string">''</span>) <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line"></div><div class="line">    <span class="keyword">this</span>.bindDirective(&#123;</div><div class="line">        node,</div><div class="line">        name: <span class="string">'text'</span>,</div><div class="line">        expression: parse.text(node.textContent),</div><div class="line">    &#125;);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>通过绑定 <code>text</code> 指令，并传入解析后的 JavaScript 表达式，在 <code>Directive</code> 内部就会计算出表达式实际的值并调用 <code>text</code> 的 <code>update</code> 函数更新视图完成渲染。</p>
<h2 id="each-指令"><a href="#each-指令" class="headerlink" title=":each 指令"></a><code>:each</code> 指令</h2><p>到目前为止，该模板引擎只实现了比较基本的功能，而最常见且重要的列表渲染功能还没有实现，所以我们现在要实现一个 <code>:each</code> 指令来渲染一个列表，这里可能要注意一下，不能按照前面两个指令的思路来实现，应该换一个角度来思考，列表渲染其实相当于一个「子模板」，里面的变量存在于 <code>:each</code> 指令所接收的 <code>data</code> 这个「局部作用域」中，这么说可能抽象，直接上代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// :each updater</span></div><div class="line"><span class="keyword">import</span> Compile <span class="keyword">from</span> <span class="string">'path/to/compile.js'</span>;</div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</div><div class="line">    beforeUpdate() &#123;</div><div class="line">        <span class="keyword">this</span>.placeholder = <span class="built_in">document</span>.createComment(<span class="string">`:each`</span>);</div><div class="line">        <span class="keyword">this</span>.node.parentNode.replaceChild(<span class="keyword">this</span>.placeholder, <span class="keyword">this</span>.node);</div><div class="line">    &#125;,</div><div class="line">    update() &#123;</div><div class="line">        <span class="keyword">if</span> (data &amp;&amp; !<span class="built_in">Array</span>.isArray(data)) <span class="keyword">return</span>;</div><div class="line"></div><div class="line">        <span class="keyword">const</span> fragment = <span class="built_in">document</span>.createDocumentFragment();</div><div class="line"></div><div class="line">        data.map(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</div><div class="line">            <span class="keyword">const</span> compiled = Compile(<span class="keyword">this</span>.node.cloneNode(<span class="literal">true</span>), &#123; item, index, &#125;);</div><div class="line">            fragment.appendChild(compiled.view);</div><div class="line">        &#125;);</div><div class="line"></div><div class="line">        <span class="keyword">this</span>.placeholder.parentNode.replaceChild(fragment, <span class="keyword">this</span>.placeholder);</div><div class="line">    &#125;,</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>在 <code>update</code> 之前，我们先把 <code>:each</code> 所在节点从 DOM 结构中去掉，但是要注意的是并不能直接去掉，而是要在去掉的位置插入一个 <code>comment</code> 类型的节点作为占位符，目的是为了在我们把列表数据渲染出来后，能找回原来的位置并把它插入到 DOM 中。</p>
<p>那具体如何编译这个所谓的「子模板」呢，首先，我们需要遍历 <code>:each</code> 指令所接收的 <code>Array</code> 类型的数据（目前只支持该类型，当然你也可以增加对 <code>Object</code> 类型的支持，原理是一样的）；其次，我们针对该列表的每一项数据进行一次模板的编译并把渲染后的模板插入到创建的 <code>document fragment</code> 中，当所有整个列表编译完后再把刚刚创建的 <code>comment</code> 类型的占位符替换为 <code>document fragment</code> 以完成列表的渲染。</p>
<p>此时，我们可以这么使用 <code>:each</code> 指令：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Compile(<span class="string">`&lt;li :each="comments" data-index="&#123;&#123; index &#125;&#125;"&gt;&#123;&#123; item.content &#125;&#125;&lt;/li&gt;`</span>, &#123;</div><div class="line">    comments: [&#123;</div><div class="line">        content: <span class="string">`Hello World.`</span>,</div><div class="line">    &#125;, &#123;</div><div class="line">        content: <span class="string">`Just Awesome.`</span>,</div><div class="line">    &#125;, &#123;</div><div class="line">        content: <span class="string">`WOW, Just WOW!`</span>,</div><div class="line">    &#125;],</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>会渲染成：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">data-index</span>=<span class="string">"0"</span>&gt;</span>Hello World.<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">data-index</span>=<span class="string">"1"</span>&gt;</span>Just Awesome.<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">data-index</span>=<span class="string">"2"</span>&gt;</span>WOW, Just WOW!<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div></pre></td></tr></table></figure>
<p>其实细心的话你会发现，模板中使用的 <code>item</code> 和 <code>index</code> 变量其实就是 <code>:each</code> 更新函数中 <code>Compile(template, data)</code> 编译器里的 <code>data</code> 值的两个 <code>key</code> 值。所以要自定义这两个变量也是非常简单的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// :each updater</span></div><div class="line"><span class="keyword">import</span> Compile <span class="keyword">from</span> <span class="string">'path/to/compile.js'</span>;</div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</div><div class="line">    beforeUpdate() &#123;</div><div class="line">        <span class="keyword">this</span>.placeholder = <span class="built_in">document</span>.createComment(<span class="string">`:each`</span>);</div><div class="line">        <span class="keyword">this</span>.node.parentNode.replaceChild(<span class="keyword">this</span>.placeholder, <span class="keyword">this</span>.node);</div><div class="line"></div><div class="line">        <span class="comment">// parse alias</span></div><div class="line">        <span class="keyword">this</span>.itemName = <span class="string">`item`</span>;</div><div class="line">        <span class="keyword">this</span>.indexName = <span class="string">`index`</span>;</div><div class="line">        <span class="keyword">this</span>.dataName = <span class="keyword">this</span>.expression;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.expression.indexOf(<span class="string">' in '</span>) != <span class="number">-1</span>) &#123;</div><div class="line">            <span class="keyword">const</span> bracketRE = <span class="regexp">/\(((?:.|\n)+?)\)/g</span>;</div><div class="line">            <span class="keyword">const</span> [item, data] = <span class="keyword">this</span>.expression.split(<span class="string">' in '</span>);</div><div class="line">            <span class="keyword">let</span> matched = <span class="literal">null</span>;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (matched = bracketRE.exec(item)) &#123;</div><div class="line">                <span class="keyword">const</span> [item, index] = matched[<span class="number">1</span>].split(<span class="string">','</span>);</div><div class="line">                index ? <span class="keyword">this</span>.indexName = index.trim() : <span class="string">''</span>;</div><div class="line">                <span class="keyword">this</span>.itemName = item.trim();</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">this</span>.itemName = item.trim();</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">this</span>.dataName = data.trim();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">this</span>.expression = <span class="keyword">this</span>.dataName;</div><div class="line">    &#125;,</div><div class="line">    update() &#123;</div><div class="line">        <span class="keyword">if</span> (data &amp;&amp; !<span class="built_in">Array</span>.isArray(data)) <span class="keyword">return</span>;</div><div class="line"></div><div class="line">        <span class="keyword">const</span> fragment = <span class="built_in">document</span>.createDocumentFragment();</div><div class="line"></div><div class="line">        data.map(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</div><div class="line">            <span class="keyword">const</span> compiled = Compile(<span class="keyword">this</span>.node.cloneNode(<span class="literal">true</span>), &#123;</div><div class="line">                [<span class="keyword">this</span>.itemName]: item,</div><div class="line">                [<span class="keyword">this</span>.indexName]: index,</div><div class="line">            &#125;);</div><div class="line">            fragment.appendChild(compiled.view);</div><div class="line">        &#125;);</div><div class="line"></div><div class="line">        <span class="keyword">this</span>.placeholder.parentNode.replaceChild(fragment, <span class="keyword">this</span>.placeholder);</div><div class="line">    &#125;,</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这样一来我们就可以通过 <code>(aliasItem, aliasIndex) in items</code> 来自定义 <code>:each</code> 指令的 <code>item</code> 和 <code>index</code> 变量了，原理就是在 <code>beforeUpdate</code> 的时候去解析 <code>:each</code> 指令的表达式，提取相关的变量名，然后上面的例子就可以写成这样了：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Compile(<span class="string">`&lt;li :each="(comment, index) in comments" data-index="&#123;&#123; index &#125;&#125;"&gt;&#123;&#123; comment.content &#125;&#125;&lt;/li&gt;`</span>, &#123;</div><div class="line">    comments: [&#123;</div><div class="line">        content: <span class="string">`Hello World.`</span>,</div><div class="line">    &#125;, &#123;</div><div class="line">        content: <span class="string">`Just Awesome.`</span>,</div><div class="line">    &#125;, &#123;</div><div class="line">        content: <span class="string">`WOW, Just WOW!`</span>,</div><div class="line">    &#125;],</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>到这里，其实一个比较简单的模板引擎算是实现了，当然还有很多地方可以完善的，比如可以增加 <code>:class</code>, <code>:style</code>, <code>:if</code> 或 <code>:src</code> 等等你可以想到的指令功能，添加这些功能都是非常的简单的。</p>
<p>全篇介绍下来，整个核心无非就是遍历整个模板的节点树，其次针对每一个节点的字符串值来解析成对应的表达式，然后通过 <code>new Function()</code> 这个构造函数来计算成实际的值，最终通过指令的 <code>update</code> 函数来更新到视图上。</p>
<p>如果还是不清楚这些指令如何编写的话，可以参考我这个项目 <a href="https://github.com/colonjs/colon" target="_blank" rel="external">colon</a> 的相关源码（部分代码可能会有不影响理解的细微差别，可忽略），有任何问题都可以在 issue 上提。</p>
<p>目前有一个局限就是 DOM-based 的模板引擎只适用于浏览器端，目前笔者也正在实现兼容 Node 端的版本，思路是把字符串模板解析成 AST，然后把更新数据到 AST 上，最后再把 AST 转成字符串模板，实现出来后有空的话再来介绍一下 Node 端的实现。</p>

            </section>
            <footer class="article-meta">
                <!--  -->
            </footer>
        </article>
    </div>
</div>

<footer class="footer text-center">
    <div class="container">
        <section class="copyright">
            <a href="http://fe.meitu.com/">MEITU FE</a>
            <span>&copy; 2017</span>
        </section>
    </div>
</footer>

    <script src="/dist/js/highlight.pack.js"></script>
    <script src="/dist/js/app.js"></script>
</body>
</html>

